# source: http://localhost:8081/graphql
# timestamp: Tue Mar 19 2019 17:17:54 GMT+0300 (MSK)

"""Cluster management"""
type Apicluster {
  """Get current server"""
  self: ServerShortInfo

  """Get current failover state."""
  failover: Boolean!

  """Whether it is reasonble to call bootstrap_vshard mutation"""
  can_bootstrap_vshard: Boolean!

  """Get list of registered roles."""
  known_roles: [String!]

  """Virtual buckets count in cluster"""
  vshard_bucket_count: Int!
}

"""
The `Long` scalar type represents non-fractional signed whole numeric values.
Long can represent values from -(2^52) to 2^52 - 1, inclusive. 
"""
scalar Long

type Mutation {
  """Cluster management"""
  cluster: MutationApicluster
  edit_server(uuid: String!, uri: String!): Boolean
  probe_server(uri: String!): Boolean
  edit_replicaset(roles: [String!], weight: Float, master: String, uuid: String!): Boolean
  join_server(instance_uuid: String, replicaset_uuid: String, timeout: Float, roles: [String!], uri: String!): Boolean
  bootstrap_vshard: Boolean
  expel_server(uuid: String!): Boolean
}

"""Cluster management"""
type MutationApicluster {
  """Enable or disable automatic failover. Returns new state."""
  failover(enabled: Boolean!): Boolean!

  """Disable listed servers by uuid"""
  disable_servers(uuids: [String!]): [Server]
}

type Query {
  """Cluster management"""
  cluster: Apicluster
  servers(uuid: String): [Server]
  replicasets(uuid: String): [Replicaset]
}

"""Group of servers replicating the same data"""
type Replicaset {
  weight: Float
  master: Server!
  roles: [String!]
  status: String!
  uuid: String!
  servers: [Server]
  active_master: Server!
}

"""Statistics for an instance in the replica set."""
type ReplicaStatus {
  downstream_status: String
  id: Int
  upstream_peer: String
  upstream_idle: Float
  upstream_message: String
  lsn: Long
  upstream_lag: Float
  upstream_status: String
  uuid: String!
  downstream_message: String
}

"""A server participating in tarantool cluster"""
type Server {
  statistics: ServerStat
  boxinfo: ServerInfo
  status: String!
  message: String!
  replicaset: Replicaset
  uri: String!
  alias: String
  disabled: Boolean!
  uuid: String!
}

"""Server information and configuration."""
type ServerInfo {
  network: ServerInfoNetwork!
  general: ServerInfoGeneral!
  replication: ServerInfoReplication!
  storage: ServerInfoStorage!
}

type ServerInfoGeneral {
  """A globally unique identifier of the instance"""
  instance_uuid: String!

  """Current read-only state"""
  ro: Boolean!

  """A directory where vinyl files or subdirectories will be stored"""
  vinyl_dir: String

  """
  The maximum number of threads to use during execution of certain internal
  processes (currently socket.getaddrinfo() and coio_call())
  """
  worker_pool_threads: Int

  """Current working directory of a process"""
  work_dir: String

  """The number of seconds since the instance started"""
  uptime: Float!

  """A directory where write-ahead log (.xlog) files are stored"""
  wal_dir: String

  """The Tarantool version"""
  version: String!

  """The binary protocol URI"""
  listen: String

  """The process ID"""
  pid: Int!

  """The UUID of the replica set"""
  replicaset_uuid: String!

  """A directory where memtx stores snapshot (.snap) files"""
  memtx_dir: String
}

type ServerInfoNetwork {
  io_collect_interval: Float
  readahead: Long
  net_msg_max: Long
}

type ServerInfoReplication {
  replication_connect_quorum: Int
  replication_connect_timeout: Float
  replication_sync_timeout: Float
  replication_skip_conflict: Boolean
  replication_sync_lag: Float

  """
  Statistics for all instances in the replica set in regard to the current instance
  """
  replication_info: [ReplicaStatus!]

  """The vector clock of replication log sequence numbers"""
  vclock: [Long]
  replication_timeout: Float
}

type ServerInfoStorage {
  wal_max_size: Long
  vinyl_run_count_per_level: Int
  rows_per_wal: Long
  vinyl_cache: Long
  vinyl_range_size: Long
  vinyl_timeout: Float
  memtx_min_tuple_size: Long
  vinyl_bloom_fpr: Float
  vinyl_page_size: Long
  memtx_max_tuple_size: Long
  vinyl_run_size_ratio: Float
  wal_mode: String
  memtx_memory: Long
  vinyl_memory: Long
  too_long_threshold: Float
  vinyl_max_tuple_size: Long
  vinyl_write_threads: Int
  vinyl_read_threads: Int
  wal_dir_rescan_delay: Float
}

"""A short server information"""
type ServerShortInfo {
  uri: String!
  uuid: String
  alias: String
}

"""
Slab allocator statistics. This can be used to monitor the total memory usage (in bytes) and memory fragmentation.
"""
type ServerStat {
  """
  The total amount of memory (including allocated, but currently free slabs) used only for tuples, no indexes
  """
  items_size: Long!

  """
  = items_used / slab_count * slab_size (these are slabs used only for tuples, no indexes)
  """
  items_used_ratio: String!

  """
  The maximum amount of memory that the slab allocator can use for both tuples
  and indexes (as configured in the memtx_memory parameter)
  """
  quota_size: Long!

  """
  The amount of memory that is already distributed to the slab allocator
  """
  quota_used: Long!

  """= arena_used / arena_size"""
  arena_used_ratio: String!

  """
  The efficient amount of memory (omitting allocated, but currently free slabs) used only for tuples, no indexes
  """
  items_used: Long!

  """= quota_used / quota_size"""
  quota_used_ratio: String!

  """
  The total memory used for tuples and indexes together (including allocated, but currently free slabs)
  """
  arena_size: Long!

  """
  The efficient memory used for storing tuples and indexes together (omitting allocated, but currently free slabs)
  """
  arena_used: Long!
}
